# frozen_string_literal: true

require "fileutils"
require "active_support/inflector"

module RailsTypedApi
  class TypeScriptGenerator
    def initialize(endpoints, rtk: false)
      @endpoints = endpoints
      @rtk = rtk
    end

    def write_to(file_path)
      FileUtils.mkdir_p(File.dirname(file_path))
      File.write(file_path, render)
    end

    def render
      lines = []
      lines << "// AUTO-GENERATED by rails_typed_api. Do not edit manually."
      if @rtk
        lines << "import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'"
      end
      lines << ""
      @endpoints.each do |ep|
        req_iface = interface_name(ep, :Request)
        res_iface = interface_name(ep, :Response)
        path_params = extract_path_params(ep[:path])

        if ep[:params_schema]
          ts = RailsTypedApi::Types.ts_type(ep[:params_schema])
          if object_schema?(ep[:params_schema])
            lines << "export interface #{req_iface} #{ts}"
          else
            lines << "export type #{req_iface} = #{ts};"
          end
        else
          if path_params.any?
            # Default path params to string type if not specified
            fields = path_params.map { |p| "#{p}: string;" }.join(" ")
            lines << "export interface #{req_iface} { #{fields} }"
          else
            lines << "export type #{req_iface} = undefined;"
          end
        end
        lines << ""
        if ep[:response_schema]
          ts = RailsTypedApi::Types.ts_type(ep[:response_schema])
          if object_schema?(ep[:response_schema])
            lines << "export interface #{res_iface} #{ts}"
          else
            lines << "export type #{res_iface} = #{ts};"
          end
        else
          lines << "export type #{res_iface} = undefined;"
        end
        lines << ""
      end

      if @rtk
        lines << rtk_client_boilerplate
      end

      lines.join("\n")
    end

    private

    def interface_name(ep, suffix)
      base = ep[:name] || (ep[:controller].to_s.split("::").last.sub(/Controller\z/, "") + ep[:action].to_s.camelize)
      base.gsub!(/[^A-Za-z0-9]/, "")
      "#{base}#{suffix}"
    end

    def object_schema?(node)
      node.is_a?(Hash)
    end

    def rtk_client_boilerplate
      <<~TS
      // Basic RTK Query API (experimental)
      export const api = createApi({
        reducerPath: 'api',
        baseQuery: fetchBaseQuery({ baseUrl: '/' }),
        endpoints: (build) => ({
          #{rtk_endpoints.join(",\n          ")}
        })
      })

      export const { #{rtk_hooks.join(', ')} } = api
      TS
    end

    def rtk_endpoints
      @endpoints.map do |ep|
        req_iface = interface_name(ep, :Request)
        res_iface = interface_name(ep, :Response)
        method = (ep[:verb].to_s.split("|").first || "GET").downcase
        key = endpoint_key(ep)
        path_params = extract_path_params(ep[:path])
        url_expr = if path_params.any?
          if %w[get delete].include?(method)
            template = ep[:path].gsub(/\{([A-Za-z_][A-Za-z0-9_]*)\}/, '${params.\\1}')
            "`#{template}`"
          else
            template = ep[:path].gsub(/\{([A-Za-z_][A-Za-z0-9_]*)\}/, '${body.\\1}')
            "`#{template}`"
          end
        else
          "'#{ep[:path]}'"
        end
        query_line = if %w[get delete].include?(method)
          if path_params.any?
            "query: (params) => ({ url: #{url_expr}, method: '#{method.upcase}' })"
          else
            "query: (params) => ({ url: #{url_expr}, method: '#{method.upcase}', params })"
          end
        else
          if path_params.any?
            "query: (body) => ({ url: #{url_expr}, method: '#{method.upcase}', body })"
          else
            "query: (body) => ({ url: #{url_expr}, method: '#{method.upcase}', body })"
          end
        end
        kind = method == 'get' ? 'query' : 'mutation'
        <<~TS.strip
        #{key}: build.#{kind}<#{res_iface}, #{req_iface}>({
              #{query_line}
            })
        TS
      end
    end

    def endpoint_key(ep)
      base = ep[:name] || (ep[:controller].to_s.split("::").last.sub(/Controller\z/, "") + "_" + ep[:action].to_s)
      base = base.gsub(/[^A-Za-z0-9]+/, '_').underscore
      base.camelize(:lower)
    end

    def rtk_hooks
      @endpoints.map do |ep|
        method = (ep[:verb].to_s.split("|").first || "GET").downcase
        suffix = method == 'get' ? 'Query' : 'Mutation'
        "use#{endpoint_key(ep).camelize}#{suffix}"
      end
    end

    def extract_path_params(path)
      (path.to_s.scan(/\{([A-Za-z_][A-Za-z0-9_]*)\}/).flatten.map(&:to_s))
    end
  end
end
